    // Initialise fluid field pointer lists
    PtrList<rhoThermo> thermoFluid(fluidRegions.size());
    PtrList<volScalarField> rhoFluid(fluidRegions.size());
    PtrList<volVectorField> UFluid(fluidRegions.size());
    PtrList<surfaceScalarField> phiFluid(fluidRegions.size());
    PtrList<uniformDimensionedVectorField> gFluid(fluidRegions.size());
    PtrList<compressible::turbulenceModel> turbulence(fluidRegions.size());
    PtrList<volScalarField> p_rghFluid(fluidRegions.size());
    PtrList<volScalarField> ghFluid(fluidRegions.size());
    PtrList<surfaceScalarField> ghfFluid(fluidRegions.size());
    PtrList<radiation::radiationModel> radiation(fluidRegions.size());

    List<scalar> initialMassFluid(fluidRegions.size());
    List<label> pRefCellFluid(fluidRegions.size(), 0);
    List<scalar> pRefValueFluid(fluidRegions.size(), 0.0);
    List<bool> frozenFlowFluid(fluidRegions.size(), false);

    PtrList<dimensionedScalar> rhoMax(fluidRegions.size());
    PtrList<dimensionedScalar> rhoMin(fluidRegions.size());

    PtrList<fv::IOoptionList> fluidFvOptions(fluidRegions.size());

    // Populate fluid field pointer lists
    forAll(fluidRegions, i)
    {
        Info<< "Reading thermophysical properties\n" << endl;

        autoPtr<psiThermo> pThermo
        (
            psiThermo::New(mesh)
        );
        psiThermo& thermo = pThermo();
        thermo.validate(args.executable(), "h", "e");

        volScalarField rho
        (
            IOobject
            (
                "rho",
                runTime.timeName(),
                mesh,
                IOobject::READ_IF_PRESENT,
                IOobject::AUTO_WRITE
            ),
            thermo.rho()
        );

        volScalarField& p = thermo.p();
        const volScalarField& psi = thermo.psi();

        Info<< "Reading field U\n" << endl;
        volVectorField U
        (
            IOobject
            (
                "U",
                runTime.timeName(),
                mesh,
                IOobject::MUST_READ,
                IOobject::AUTO_WRITE
            ),
            mesh
        );

        #include "compressibleCreatePhi.H"


        label pRefCell = 0;
        scalar pRefValue = 0.0;
        setRefCell(p, simple.dict(), pRefCell, pRefValue);

        dimensionedScalar rhoMax(simple.dict().lookup("rhoMax"));
        dimensionedScalar rhoMin(simple.dict().lookup("rhoMin"));

        Info<< "Creating turbulence model\n" << endl;
        autoPtr<compressible::RASModel> turbulence
        (
            compressible::RASModel::New
            (
                rho,
                U,
                phi,
                thermo
            )
        );

        dimensionedScalar initialMass = fvc::domainIntegrate(rho);
    }


